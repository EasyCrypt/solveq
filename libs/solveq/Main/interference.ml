open Core
open Monalg
open Types
open GroebnerBasis

exception RemainderNotUniform

module Dependencies(R : Field)(S : Monalg.MonAlgebra with type ring = R.t and type mon = X.t)(P : Monalg.ProductAlgebra with type ringA = S.t and type ringB = S.t)
=
struct
  module C = Converter(R)(S)

  module GB = GroebnerBasis.ProdGB(R)(S)(P)
  module VarMap = Map.Make(Var)
  module VarSet = Set.Make(Var)
  module I = Ring_inverter.InvertMonalg(R)(S)    
  module U = Uniform.Unif(R)(S)(P)

  let is_witness (p : S.t) (rndvars) detvars =
    (VarSet.is_empty (VarSet.inter rndvars (C.varset p)))
    (* a witness is valid if does not contain any random variables *)
    &&
    (
      let rec linear_indep p detvars =
        match S.split p with
        | None -> true
        | Some((x,r),q) -> let varmon = X.varset x in
          (* and if each monom depends eiter only on detvars, or on fresh vars *)
          ( (VarSet.subset varmon detvars) || (VarSet.is_empty (VarSet.inter varmon detvars))  ) && (linear_indep q detvars)
      in
      linear_indep p detvars
    )

  (* we get the variables v such that P = vQ or P = (1+v)Q *)
  let v_mult_dep p detvars =
    let rec var_factor (p : S.t) =
      match S.split p with
      | None -> VarSet.empty
      | Some((x,r),q) ->
        match S.split q with
        | None -> X.varset x
        | Some(_) -> VarSet.inter (X.varset x) (var_factor q)
    in
    (* we start by getting the vars such that P = vQ *)
    let multdepvar = VarSet.inter (var_factor p) detvars in
    (* we set ovars to possible candidates such that P=(1+v)Q *)
     let ovars = VarSet.inter (C.varset p) (VarSet.diff detvars multdepvar) in
    (* we only keep ovars such that P = Q+ vQ *)
         let ovars = VarSet.filter (fun v -> let p1,p2 = I.euclidian_div v p in S.eq p1 p2) ovars in
    VarSet.union multdepvar ovars
    
  (* try to divide as much as possible p by either v or v+1 *)
  let rec div_by_dets p detvars =
    let rec aux p detvars boundvars =
      if VarSet.is_empty detvars then
        p,boundvars
      else
        (
          let var, ndetvars = VarSet.pop detvars in
          let p1,p2 = I.euclidian_div var p in
          if S.eq p1 p2 || S.eq p2 S.zero then (* if p = (v+1)p1 or p = vp1 *)
            aux p1 ndetvars (VarSet.add var boundvars)
          else
            aux p ndetvars boundvars
        )
    in
    aux p detvars VarSet.empty
  
  (* Given a list of polynoms pols, depending on deterministic variables detvars and random variables rndvars, computes all combinations of pols and deterministic variables such that it is equal to something only over deterministic variables.
Those combinations corresponds to dependencies between some polynoms and determnistic variables. 
We exctract from those combinations boundvars,boundpols,unboundpol where boundvars are the variable whose distribution is not independent from the distribution of boundpols. unboundpols are polynomials that depends on random variables, but might still reveal some informations on the deterministic variables.
  *)
  let get_dependencies (pols : S.t list) (detvars : Set.Make(Var).t) (rndvars : Set.Make(Var).t) =
    (*  All variables in the polynom must be detvars union rnd vars. All variables in rndvars must be greater than those in detvars, and those in detvars greater than the fresh variable starting in "f". For instance, all variables in rndvar could be prefixed with "z", all those in det with "x". *)
    let counter = ref (0) in
    let map = ref VarMap.empty in
      let ps = List.fold_left (fun acc poly ->
        counter := !counter+1;
        let fvar = Var.make_fresh (Var.of_int (!counter))  in
        let fresh_var =  S.form R.unit (X.ofvar fvar)  in
        map := VarMap.add fvar poly (!map);
          ((poly,fresh_var))::acc
        ) [(S.unit, S.unit )] pols in
      let basis = GB.syz rndvars ps in
      (* we compute the GB of the subalgebra generated by <pols,1>, when allowing to multiply by detvars only.*)
      (* the extra variables fi allow to keep track of the computations, each element in the basis which does not depend on rnd vars is an element of the sizygy of <pols,detvars> *)
      let depvars = ref VarSet.empty in
      let res = List.filter (fun p -> is_witness p rndvars detvars) basis in
      let boundvarpol = List.fold_left (fun acc pol -> VarSet.union (C.varset pol) acc) VarSet.empty res in
      let boundvar = VarSet.inter boundvarpol detvars in
    let boundpol,unboundpol = VarMap.partition (fun varpol pol -> VarSet.mem varpol boundvarpol) (!map)
    in
    (* we now try to collect more depencies, for polynoms leaking variables v with P=vQ or P=(v+1)Q *)
    let newboundvars = ref VarSet.empty in
    let reduceunboundpol = VarMap.fold
        (fun varpol pol l ->
           let p, nboundvars = div_by_dets pol detvars in
           newboundvars := VarSet.union (!newboundvars) nboundvars;
           p::l
        )  unboundpol [] in
    let boundvar = VarSet.union boundvar (!newboundvars) in
    (* from the boundvariables, we now split the reduce unbound pols into polynomaisl that are bound (no det variables unbound) or that may need to be uniform *)
    let extraboundpol,unboundpol = List.partition  (fun pol -> VarSet.subset (VarSet.inter detvars (C.varset pol)) (boundvar) ) reduceunboundpol in
    let tolist = fun x -> List.map (fun (u,v) -> v) (VarMap.bindings x) in
    
    let boundpol = (tolist boundpol)@(extraboundpol) and unboundpol = unboundpol in
    VarSet.to_list boundvar, boundpol, unboundpol, res
      
  let check_indep (pols : S.t list) (detvars : Set.Make(Var).t) (rndvars : Set.Make(Var).t) =
    (* we first collect the dependencies *)
    let boundvars, boundpols, unboundpols,witnesses = get_dependencies pols detvars rndvars in
    (* we should now analyze the unbound polynomials, to see if they preserve interference *)
    if unboundpols = [] then
      if List.for_all (fun pol -> VarSet.subset (C.varset pol) (VarSet.of_list boundvars) ) boundpols then
        boundvars,witnesses, `Uniform
      else
        boundvars,witnesses, `NotAllDependenciesFound
    else
      begin
        (* reasonable hypothesis at this point, unboundpols is independent from (detvars/boundvars) *)
        let rndvarsboundpol = List.fold_left  (fun acc pol -> VarSet.union (C.varset pol) acc) VarSet.empty boundpols in
        let diff = VarSet.diff rndvars rndvarsboundpol in
        if U.naive_is_unif unboundpols diff then
          (* if the unbound pols are uniform, they reveal nothing about the remaining variables. The only bound variables as thus the ones found previously, if the boundpol only reveal them. *)
          if List.for_all (fun pol -> VarSet.subset (VarSet.inter detvars (C.varset pol)) (VarSet.of_list boundvars) ) boundpols then
            boundvars,witnesses, `Uniform
          else
            boundvars,witnesses, `NotAllDependenciesFound
        else
          (* should develop here for more complete methods*)
          (
            (* Format.printf "not unif:" ;
            List.iter (fun v -> Format.printf " (%a) " S.pp v)  unboundpols;    
               Format.printf "@." ; *)
          boundvars,witnesses, `RemainderNotUniform)
      end
      
  let check_indep_ring (rings : ring list) (detvars : Set.Make(Var).t) (rndvars : Set.Make(Var).t) =
    let pols =  List.map (C.ring_to_monalg ~rndvars:(rndvars)) rings in
    let detvars = VarSet.fold (fun var acc -> VarSet.add (Var.make_det var) acc ) detvars VarSet.empty and
       rndvars = VarSet.fold (fun var acc -> VarSet.add (Var.make_rnd var) acc ) rndvars VarSet.empty in
    (* Here, we have prefixes to detvars and rndvars so that the ordering invariant required for getdependencies are met *)
    check_indep pols detvars rndvars
(* given a list of rings elements, a list of deterministic variables,, either of infinite characteristic or characteristic two, we give back the set of dependent variables *)

end


module RingDep =  Dependencies(R)(S)(P)

let check_indep_ring = RingDep.check_indep_ring

module RingBoolDep =  Dependencies(B)(SB)(PB)

let check_indep_ringbool = RingBoolDep.check_indep_ring
