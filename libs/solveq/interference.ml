open Core
open Monalg
open Types
open GroebnerBasis

module Dependencies(R : Field)(S : Monalg.MonAlgebra with type ring = R.t and type mon = X.t)(P : Monalg.ProductAlgebra with type ringA = S.t and type ringB = S.t)
=
struct
  module C = Converter(R)(S)

  module GB = GroebnerBasis.ProdGB(R)(S)(P)
  module M = Map.Make(V)
 module Se = Set.Make(V)
  module U = Uniform.Unif(R)(S)(P)
  exception Unknown

  (* Given a list of polynoms pols, depending on deterministic variables detvars and random variables rndvars, computes all combinations of pols and deterministic variables such that it is equal to something only over deterministic variables.
Those combinations corresponds to dependencies between some polynoms and determnistic variables. 
We exctract from those combinations boundvars,boundpols,unboundpol where boundvars are the variable whose distribution is not independent from the distribution of boundpols. unboundpols are polynomials that depends on random variables, but might still reveal some informations on the deterministic variables.
  *)
  let get_dependencies (pols : S.t list) (detvars : Set.Make(V).t) (rndvars : Set.Make(V).t) =
    (*  All variables in the polynom must be detvars union rnd vars. All variables in rndvars must be greater than those in detvars, and those in detvars greater than the fresh variable starting in "f". For instance, all variables in rndvar could be prefixed with "z", all those in det with "x". *)
    let counter = ref (0) in
    let map = ref M.empty in
      let ps = List.fold_left (fun acc poly ->
          counter := !counter+1;
          let fresh_var =  S.form R.unit (X.ofvar (pvar_of_var (!counter)  ~pref:"f" ))  in
          map := M.add (pvar_of_var (!counter)  ~pref:"f" ) poly (!map);
          ((S.(-!) poly fresh_var,fresh_var))::acc
        ) [(S.unit, S.unit )] pols in
      let basis = GB.syz rndvars ps in
      (* we compute the GB of the subalgebra generated by <pols,1>, when allowing to multiply by detvars only.*)
      (* the extra variables fi allow to keep track of the computations, each element in the basis which does not depend on rnd vars is an element of the sizygy of <pols,detvars> *)
      let depvars = ref Se.empty in
      let res = List.filter (fun pol ->
          Se.is_empty (Se.inter rndvars (C.varset pol))
        )
          basis in
      let boundvarpol = List.fold_left (fun acc pol -> Se.union (C.varset pol) acc) Se.empty res in
      let boundvar = Se.inter boundvarpol detvars in
    let boundpol,unboundpol = M.partition (fun varpol pol -> Se.mem varpol boundvarpol) (!map) in
    let tolist = fun x -> List.map (fun (u,v) -> v) (M.bindings x) in
    Se.to_list boundvar, tolist boundpol, tolist unboundpol
      
  let check_indep (pols : S.t list) (detvars : Set.Make(V).t) (rndvars : Set.Make(V).t) =
    (* we first collect the dependencies *)
    let boundvars, boundpols, unboundpols = get_dependencies pols detvars rndvars in
    (* we should now analyze the unbound polynomials, to see if they preserve interference *)
    (* reasonable hypothesis at this point, unboundpols is independent from (detvars/boundvars) *)
    if U.naive_is_unif unboundpols rndvars then
      (* if the unbound pols are uniform, they reveal nothing about the remaining variables. The only bound variables as thus the ones found previously. *)
      boundvars
    else
      (* should develop here for more complete methods*)
      raise Unknown

  let check_indep_ring (rings : ring list) (detvars : var list) (rndvars : var list) =
    let detvars = Se.of_list (List.map (pvar_of_var ~pref:"x") detvars) and
    rndvars = Se.of_list (List.map (pvar_of_var ~pref:"z") rndvars) in
    (* Here, we have prefixes to detvars and rndvars so that the ordering invariant required for getdependencies are met *)
    let pols =  List.map C.ring_to_monalg rings in
    List.map (var_of_pvar) (check_indep pols detvars rndvars)
(* given a list of rings elements, a list of deterministic variables,, either of infinite characteristic or characteristic two, we give back the set of dependent variables *)

end


module RingDep =  Dependencies(R)(S)(P)

let check_indep_ring = RingDep.check_indep_ring

module RingBoolDep =  Dependencies(B)(SB)(PB)

let check_indep_ringbool = RingDep.check_indep_ring
