open Core
open Monalg
open Types
open GroebnerBasis

exception RemainderNotUniform

module Dependencies(R : Field)(S : Monalg.MonAlgebra with type ring = R.t and type mon = X.t)(P : Monalg.ProductAlgebra with type ringA = S.t and type ringB = S.t)
=
struct
  module C = Converter(R)(S)

  module GB = GroebnerBasis.ProdGB(R)(S)(P)
  module VarMap = Map.Make(Var)
  module VarSet = Set.Make(Var)
      
  module U = Uniform.Unif(R)(S)(P)

  (* Given a list of polynoms pols, depending on deterministic variables detvars and random variables rndvars, computes all combinations of pols and deterministic variables such that it is equal to something only over deterministic variables.
Those combinations corresponds to dependencies between some polynoms and determnistic variables. 
We exctract from those combinations boundvars,boundpols,unboundpol where boundvars are the variable whose distribution is not independent from the distribution of boundpols. unboundpols are polynomials that depends on random variables, but might still reveal some informations on the deterministic variables.
  *)
  let get_dependencies (pols : S.t list) (detvars : Set.Make(Var).t) (rndvars : Set.Make(Var).t) =
    (*  All variables in the polynom must be detvars union rnd vars. All variables in rndvars must be greater than those in detvars, and those in detvars greater than the fresh variable starting in "f". For instance, all variables in rndvar could be prefixed with "z", all those in det with "x". *)
    let counter = ref (0) in
    let map = ref VarMap.empty in
      let ps = List.fold_left (fun acc poly ->
        counter := !counter+1;
        let fvar = Var.make_fresh (Var.of_int (!counter))  in
        let fresh_var =  S.form R.unit (X.ofvar fvar)  in
        map := VarMap.add fvar poly (!map);
          ((poly,fresh_var))::acc
        ) [(S.unit, S.unit )] pols in
      let basis = GB.syz rndvars ps in
      (* we compute the GB of the subalgebra generated by <pols,1>, when allowing to multiply by detvars only.*)
      (* the extra variables fi allow to keep track of the computations, each element in the basis which does not depend on rnd vars is an element of the sizygy of <pols,detvars> *)
      let depvars = ref VarSet.empty in
      let res = List.filter (fun pol ->
          VarSet.is_empty (VarSet.inter rndvars (C.varset pol))
        )
          basis in
      let boundvarpol = List.fold_left (fun acc pol -> VarSet.union (C.varset pol) acc) VarSet.empty res in
      let boundvar = VarSet.inter boundvarpol detvars in
    let boundpol,unboundpol = VarMap.partition (fun varpol pol -> VarSet.mem varpol boundvarpol) (!map)
    in
    let tolist = fun x -> List.map (fun (u,v) -> v) (VarMap.bindings x) in
    VarSet.to_list boundvar, tolist boundpol, tolist unboundpol, res
      
  let check_indep (pols : S.t list) (detvars : Set.Make(Var).t) (rndvars : Set.Make(Var).t) =
    (* we first collect the dependencies *)
    let boundvars, boundpols, unboundpols,witnesses = get_dependencies pols detvars rndvars in
    (* we should now analyze the unbound polynomials, to see if they preserve interference *)
    if unboundpols = [] then
      boundvars,witnesses
    else
      begin
        (* reasonable hypothesis at this point, unboundpols is independent from (detvars/boundvars) *)
        let rndvarsboundpol = List.fold_left  (fun acc pol -> VarSet.union (C.varset pol) acc) VarSet.empty boundpols in
        
        if U.naive_is_unif unboundpols (VarSet.diff rndvars rndvarsboundpol) then
          (* if the unbound pols are uniform, they reveal nothing about the remaining variables. The only bound variables as thus the ones found previously. *)
          boundvars,witnesses
        else
          (* should develop here for more complete methods*)
          raise RemainderNotUniform
      end
  let check_indep_ring (rings : ring list) (detvars : Set.Make(Var).t) (rndvars : Set.Make(Var).t) =
    let pols =  List.map (C.ring_to_monalg ~rndvars:(rndvars)) rings in
    let detvars = VarSet.fold (fun var acc -> VarSet.add (Var.make_det var) acc ) detvars VarSet.empty and
       rndvars = VarSet.fold (fun var acc -> VarSet.add (Var.make_rnd var) acc ) rndvars VarSet.empty in
    (* Here, we have prefixes to detvars and rndvars so that the ordering invariant required for getdependencies are met *)
    check_indep pols detvars rndvars
(* given a list of rings elements, a list of deterministic variables,, either of infinite characteristic or characteristic two, we give back the set of dependent variables *)

end


module RingDep =  Dependencies(R)(S)(P)

let check_indep_ring = RingDep.check_indep_ring

module RingBoolDep =  Dependencies(B)(SB)(PB)

let check_indep_ringbool = RingBoolDep.check_indep_ring
